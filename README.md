# DesignPatterns
[TOC]



## 策略模式

### 策略模式原理

#### **分别封装行为接口实现算法族，超类里面放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者** 

### 个人讲解：
多种类型的鸭子，不同种类的鸭子行为方式不同，比如A类鸭子呱呱叫，B类鸭子喵喵叫。为了方便扩展，将鸭子叫抽象为一个接口，具体怎么叫，由下面的实现类去实现。在鸭子的超类里面，增加一个属性就是叫的方式，具体对象在鸭子的子类里面去实现。
这就相当于各种叫法是鸭子的策略，是原理当中提到的算法，具体采用哪种算法（鸭子的叫法）是由鸭子具体子类说了算的。

## 观察者模式

使用Java内置的观察者。

**在通知观察者之前需要调用setChanged()，否则没有通知观察者**



## 工厂模式

#### 简单工厂模式：一个工厂生产所有产品

#### 工厂模式：一个工厂生产一个对应产品。工厂没有抽象出来，只是把生产方法抽象出来了。

#### 抽象工厂模式：一个工厂生产一族产品。注意一类和一族产品的区别，卡车的轮子和卡车的灯是一簇产品。卡车的轮子和客车的轮子属于类产品。



**1、简单工厂模式**（一个工厂生产所有产品）：

- Factory：工厂角色

​            工厂角色负责实现创建所有实例的内部逻辑

- Product：抽象产品角色

​            抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口

- ConcreteProduct：具体产品角色

​            具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

![img](file:///C:/Users/sun/AppData/Local/Temp/enhtmlclip/Image.jpg)



**1.1、简单工厂模式的优点**

- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。



**1.2、简单工厂模式的缺点**

- 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。



**1.3、适用环境**

在以下情况下可以使用简单工厂模式：

- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。





**2、工厂模式**（一个工厂生产一个对应产品）：

```定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。```

**在pizza的订单的例子中，OrderPizza这个类里面，createPizza()方法被抽象出来，具体的定义在OrderPizza的子类LDOrderPizza等类中实现。而抽象工厂模式则是有一个接口（AbsFactory）写了CreatePizza()，然后LDFactory等工厂实现该接口和该方法。在OrderPizza中有一个实例对象是AbsFactory,初始化的时候会传入具体的工厂子类。然后在OrderPizza中调用了工厂的创建pizza。  **

- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂

![img](file:///C:/Users/sun/AppData/Local/Temp/enhtmlclip/Image(1).jpg)

**2.1. 工厂方法模式的优点**

- 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
- 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。

**2.2. 工厂方法模式的缺点**

- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

**2.3. 适用环境**

在以下情况下可以使用工厂方法模式：

- 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
- 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。



**3、抽象工厂模式**（一个工厂生产一族产品）：

``` 定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类 ```

- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂
- AbstractProduct：抽象产品
- Product：具体产品

![img](file:///C:/Users/sun/AppData/Local/Temp/enhtmlclip/Image(2).jpg)

**3.8. 优点**

- 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
- 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。



**3.9. 缺点**

- 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
- 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦，例如：制造车的工厂，增加一种其他任何一种车的制造，只需要增加一个新的工厂生产此车。但如果想要增加一个备胎，那就需要修改每一个工厂）。



**3.10. 适用环境**

在以下情况下可以使用抽象工厂模式：

- **一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的**。
- 系统中有多于一个的产品族，而每次只使用其中某一产品族。
- 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
- 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。





## 装饰者模式

**动态的将新功能附加到对象上，在对象功能扩展方面，他比继承有弹性。在某些时候如果使用继承的话，会导致类爆炸。类似于n种A物品与m种B物品组合形成m\*n种类，这也就导致了类爆炸，而装饰者模式能够很好的解决这个问题**


[代码参考]([参考](https://github.com/lazysunshinesmile/DesignPatterns/tree/master/DecoratorMode)
)

### 易错点提及
- 被装饰者（咖啡）初始化函数是正常的，装饰者（配料）的初始化函数需要传入装饰者与被装饰者的共同父类（Drink）。
- 由于上一点，导致了被装饰者的方法不需要递归调用，也就意味着他们是递归调用的尽头。
```java
public class Coffee extends Drink {

    public Coffee() {
        setDescribtion("pure coffee 10");
        setPrice(10f);
    }

    @Override
    public String describe() {
        return getmDescribtion();
    }

    @Override
    public float cost() {
        return getPrice();
    }
}

```
- 装饰者由于需要递归调用，那么在初始化函数当中就要传入同类的对象。在一些方法中递归调用。如下面的describe和cost方法。
```java
public class Seasoning extends Drink {
    protected Drink mDrink;

    public Seasoning(Drink drink) {
        this.mDrink = drink;
    }


    @Override
    public String describe() {
    //本身的描述 + "&&" + 递归调用描述 
        return super.getmDescribtion() + " && " + mDrink.describe();
    }

    @Override
    public float cost() {
      //本身的价格 + "&&" + 递归调用价格
        return super.getPrice() + mDrink.cost();
    }
}

```



## 命令模式

### 命令模式类图
![命令模式类图](https://github.com/lazysunshinesmile/DesignPatterns/blob/master/CommandModel/src/image/FireShot%20Pro%20Screen%20Capture%20%23002%20-%20'Image_webp%20(531%C3%97382)'%20-%20file.png)

### 原理
将请求、命令、动作等封装成对象，这样可以让项目使用这些对象来参数化其他对象。使得命令的请求者和执行者解耦。

### 作用
命令模式的作用是把发射命令的对象和接收命令的对象分隔开来。
